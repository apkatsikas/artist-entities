// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"github.com/apkatsikas/artist-entities/models"
	"github.com/apkatsikas/artist-entities/storageclient"
	mock "github.com/stretchr/testify/mock"
	"gorm.io/gorm"
)

// NewIAdminRepository creates a new instance of IAdminRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIAdminRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *IAdminRepository {
	mock := &IAdminRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IAdminRepository is an autogenerated mock type for the IAdminRepository type
type IAdminRepository struct {
	mock.Mock
}

type IAdminRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *IAdminRepository) EXPECT() *IAdminRepository_Expecter {
	return &IAdminRepository_Expecter{mock: &_m.Mock}
}

// CreateBackup provides a mock function for the type IAdminRepository
func (_mock *IAdminRepository) CreateBackup(file string) error {
	ret := _mock.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for CreateBackup")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(file)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IAdminRepository_CreateBackup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBackup'
type IAdminRepository_CreateBackup_Call struct {
	*mock.Call
}

// CreateBackup is a helper method to define mock.On call
//   - file
func (_e *IAdminRepository_Expecter) CreateBackup(file interface{}) *IAdminRepository_CreateBackup_Call {
	return &IAdminRepository_CreateBackup_Call{Call: _e.mock.On("CreateBackup", file)}
}

func (_c *IAdminRepository_CreateBackup_Call) Run(run func(file string)) *IAdminRepository_CreateBackup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IAdminRepository_CreateBackup_Call) Return(err error) *IAdminRepository_CreateBackup_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IAdminRepository_CreateBackup_Call) RunAndReturn(run func(file string) error) *IAdminRepository_CreateBackup_Call {
	_c.Call.Return(run)
	return _c
}

// NewIAdminRules creates a new instance of IAdminRules. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIAdminRules(t interface {
	mock.TestingT
	Cleanup(func())
}) *IAdminRules {
	mock := &IAdminRules{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IAdminRules is an autogenerated mock type for the IAdminRules type
type IAdminRules struct {
	mock.Mock
}

type IAdminRules_Expecter struct {
	mock *mock.Mock
}

func (_m *IAdminRules) EXPECT() *IAdminRules_Expecter {
	return &IAdminRules_Expecter{mock: &_m.Mock}
}

// FileToDelete provides a mock function for the type IAdminRules
func (_mock *IAdminRules) FileToDelete(files []storageclient.BackupFile) string {
	ret := _mock.Called(files)

	if len(ret) == 0 {
		panic("no return value specified for FileToDelete")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func([]storageclient.BackupFile) string); ok {
		r0 = returnFunc(files)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// IAdminRules_FileToDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FileToDelete'
type IAdminRules_FileToDelete_Call struct {
	*mock.Call
}

// FileToDelete is a helper method to define mock.On call
//   - files
func (_e *IAdminRules_Expecter) FileToDelete(files interface{}) *IAdminRules_FileToDelete_Call {
	return &IAdminRules_FileToDelete_Call{Call: _e.mock.On("FileToDelete", files)}
}

func (_c *IAdminRules_FileToDelete_Call) Run(run func(files []storageclient.BackupFile)) *IAdminRules_FileToDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]storageclient.BackupFile))
	})
	return _c
}

func (_c *IAdminRules_FileToDelete_Call) Return(s string) *IAdminRules_FileToDelete_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *IAdminRules_FileToDelete_Call) RunAndReturn(run func(files []storageclient.BackupFile) string) *IAdminRules_FileToDelete_Call {
	_c.Call.Return(run)
	return _c
}

// NewIArtistRepository creates a new instance of IArtistRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIArtistRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *IArtistRepository {
	mock := &IArtistRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IArtistRepository is an autogenerated mock type for the IArtistRepository type
type IArtistRepository struct {
	mock.Mock
}

type IArtistRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *IArtistRepository) EXPECT() *IArtistRepository_Expecter {
	return &IArtistRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type IArtistRepository
func (_mock *IArtistRepository) Create(name string) (*models.Artist, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *models.Artist
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*models.Artist, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *models.Artist); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Artist)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IArtistRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type IArtistRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - name
func (_e *IArtistRepository_Expecter) Create(name interface{}) *IArtistRepository_Create_Call {
	return &IArtistRepository_Create_Call{Call: _e.mock.On("Create", name)}
}

func (_c *IArtistRepository_Create_Call) Run(run func(name string)) *IArtistRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IArtistRepository_Create_Call) Return(artist *models.Artist, err error) *IArtistRepository_Create_Call {
	_c.Call.Return(artist, err)
	return _c
}

func (_c *IArtistRepository_Create_Call) RunAndReturn(run func(name string) (*models.Artist, error)) *IArtistRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type IArtistRepository
func (_mock *IArtistRepository) Get(id uint) (*models.Artist, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *models.Artist
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint) (*models.Artist, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(uint) *models.Artist); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Artist)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IArtistRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type IArtistRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - id
func (_e *IArtistRepository_Expecter) Get(id interface{}) *IArtistRepository_Get_Call {
	return &IArtistRepository_Get_Call{Call: _e.mock.On("Get", id)}
}

func (_c *IArtistRepository_Get_Call) Run(run func(id uint)) *IArtistRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint))
	})
	return _c
}

func (_c *IArtistRepository_Get_Call) Return(artist *models.Artist, err error) *IArtistRepository_Get_Call {
	_c.Call.Return(artist, err)
	return _c
}

func (_c *IArtistRepository_Get_Call) RunAndReturn(run func(id uint) (*models.Artist, error)) *IArtistRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetByOffset provides a mock function for the type IArtistRepository
func (_mock *IArtistRepository) GetByOffset(offset uint) (*models.Artist, error) {
	ret := _mock.Called(offset)

	if len(ret) == 0 {
		panic("no return value specified for GetByOffset")
	}

	var r0 *models.Artist
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint) (*models.Artist, error)); ok {
		return returnFunc(offset)
	}
	if returnFunc, ok := ret.Get(0).(func(uint) *models.Artist); ok {
		r0 = returnFunc(offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Artist)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint) error); ok {
		r1 = returnFunc(offset)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IArtistRepository_GetByOffset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByOffset'
type IArtistRepository_GetByOffset_Call struct {
	*mock.Call
}

// GetByOffset is a helper method to define mock.On call
//   - offset
func (_e *IArtistRepository_Expecter) GetByOffset(offset interface{}) *IArtistRepository_GetByOffset_Call {
	return &IArtistRepository_GetByOffset_Call{Call: _e.mock.On("GetByOffset", offset)}
}

func (_c *IArtistRepository_GetByOffset_Call) Run(run func(offset uint)) *IArtistRepository_GetByOffset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint))
	})
	return _c
}

func (_c *IArtistRepository_GetByOffset_Call) Return(artist *models.Artist, err error) *IArtistRepository_GetByOffset_Call {
	_c.Call.Return(artist, err)
	return _c
}

func (_c *IArtistRepository_GetByOffset_Call) RunAndReturn(run func(offset uint) (*models.Artist, error)) *IArtistRepository_GetByOffset_Call {
	_c.Call.Return(run)
	return _c
}

// GetCount provides a mock function for the type IArtistRepository
func (_mock *IArtistRepository) GetCount() (uint, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCount")
	}

	var r0 uint
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (uint, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() uint); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(uint)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IArtistRepository_GetCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCount'
type IArtistRepository_GetCount_Call struct {
	*mock.Call
}

// GetCount is a helper method to define mock.On call
func (_e *IArtistRepository_Expecter) GetCount() *IArtistRepository_GetCount_Call {
	return &IArtistRepository_GetCount_Call{Call: _e.mock.On("GetCount")}
}

func (_c *IArtistRepository_GetCount_Call) Run(run func()) *IArtistRepository_GetCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IArtistRepository_GetCount_Call) Return(v uint, err error) *IArtistRepository_GetCount_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *IArtistRepository_GetCount_Call) RunAndReturn(run func() (uint, error)) *IArtistRepository_GetCount_Call {
	_c.Call.Return(run)
	return _c
}

// Migrate provides a mock function for the type IArtistRepository
func (_mock *IArtistRepository) Migrate() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Migrate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IArtistRepository_Migrate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Migrate'
type IArtistRepository_Migrate_Call struct {
	*mock.Call
}

// Migrate is a helper method to define mock.On call
func (_e *IArtistRepository_Expecter) Migrate() *IArtistRepository_Migrate_Call {
	return &IArtistRepository_Migrate_Call{Call: _e.mock.On("Migrate")}
}

func (_c *IArtistRepository_Migrate_Call) Run(run func()) *IArtistRepository_Migrate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IArtistRepository_Migrate_Call) Return(err error) *IArtistRepository_Migrate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IArtistRepository_Migrate_Call) RunAndReturn(run func() error) *IArtistRepository_Migrate_Call {
	_c.Call.Return(run)
	return _c
}

// NewIArtistRules creates a new instance of IArtistRules. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIArtistRules(t interface {
	mock.TestingT
	Cleanup(func())
}) *IArtistRules {
	mock := &IArtistRules{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IArtistRules is an autogenerated mock type for the IArtistRules type
type IArtistRules struct {
	mock.Mock
}

type IArtistRules_Expecter struct {
	mock *mock.Mock
}

func (_m *IArtistRules) EXPECT() *IArtistRules_Expecter {
	return &IArtistRules_Expecter{mock: &_m.Mock}
}

// CleanArtistName provides a mock function for the type IArtistRules
func (_mock *IArtistRules) CleanArtistName(s string) (string, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for CleanArtistName")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (string, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IArtistRules_CleanArtistName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CleanArtistName'
type IArtistRules_CleanArtistName_Call struct {
	*mock.Call
}

// CleanArtistName is a helper method to define mock.On call
//   - s
func (_e *IArtistRules_Expecter) CleanArtistName(s interface{}) *IArtistRules_CleanArtistName_Call {
	return &IArtistRules_CleanArtistName_Call{Call: _e.mock.On("CleanArtistName", s)}
}

func (_c *IArtistRules_CleanArtistName_Call) Run(run func(s string)) *IArtistRules_CleanArtistName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IArtistRules_CleanArtistName_Call) Return(s1 string, err error) *IArtistRules_CleanArtistName_Call {
	_c.Call.Return(s1, err)
	return _c
}

func (_c *IArtistRules_CleanArtistName_Call) RunAndReturn(run func(s string) (string, error)) *IArtistRules_CleanArtistName_Call {
	_c.Call.Return(run)
	return _c
}

// RandomOffset provides a mock function for the type IArtistRules
func (_mock *IArtistRules) RandomOffset(count uint) uint {
	ret := _mock.Called(count)

	if len(ret) == 0 {
		panic("no return value specified for RandomOffset")
	}

	var r0 uint
	if returnFunc, ok := ret.Get(0).(func(uint) uint); ok {
		r0 = returnFunc(count)
	} else {
		r0 = ret.Get(0).(uint)
	}
	return r0
}

// IArtistRules_RandomOffset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RandomOffset'
type IArtistRules_RandomOffset_Call struct {
	*mock.Call
}

// RandomOffset is a helper method to define mock.On call
//   - count
func (_e *IArtistRules_Expecter) RandomOffset(count interface{}) *IArtistRules_RandomOffset_Call {
	return &IArtistRules_RandomOffset_Call{Call: _e.mock.On("RandomOffset", count)}
}

func (_c *IArtistRules_RandomOffset_Call) Run(run func(count uint)) *IArtistRules_RandomOffset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint))
	})
	return _c
}

func (_c *IArtistRules_RandomOffset_Call) Return(v uint) *IArtistRules_RandomOffset_Call {
	_c.Call.Return(v)
	return _c
}

func (_c *IArtistRules_RandomOffset_Call) RunAndReturn(run func(count uint) uint) *IArtistRules_RandomOffset_Call {
	_c.Call.Return(run)
	return _c
}

// NewIArtistService creates a new instance of IArtistService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIArtistService(t interface {
	mock.TestingT
	Cleanup(func())
}) *IArtistService {
	mock := &IArtistService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IArtistService is an autogenerated mock type for the IArtistService type
type IArtistService struct {
	mock.Mock
}

type IArtistService_Expecter struct {
	mock *mock.Mock
}

func (_m *IArtistService) EXPECT() *IArtistService_Expecter {
	return &IArtistService_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type IArtistService
func (_mock *IArtistService) Create(artistName string) (*models.Artist, error) {
	ret := _mock.Called(artistName)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *models.Artist
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*models.Artist, error)); ok {
		return returnFunc(artistName)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *models.Artist); ok {
		r0 = returnFunc(artistName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Artist)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(artistName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IArtistService_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type IArtistService_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - artistName
func (_e *IArtistService_Expecter) Create(artistName interface{}) *IArtistService_Create_Call {
	return &IArtistService_Create_Call{Call: _e.mock.On("Create", artistName)}
}

func (_c *IArtistService_Create_Call) Run(run func(artistName string)) *IArtistService_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IArtistService_Create_Call) Return(artist *models.Artist, err error) *IArtistService_Create_Call {
	_c.Call.Return(artist, err)
	return _c
}

func (_c *IArtistService_Create_Call) RunAndReturn(run func(artistName string) (*models.Artist, error)) *IArtistService_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type IArtistService
func (_mock *IArtistService) Get(id uint) (*models.Artist, error) {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *models.Artist
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(uint) (*models.Artist, error)); ok {
		return returnFunc(id)
	}
	if returnFunc, ok := ret.Get(0).(func(uint) *models.Artist); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Artist)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(uint) error); ok {
		r1 = returnFunc(id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IArtistService_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type IArtistService_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - id
func (_e *IArtistService_Expecter) Get(id interface{}) *IArtistService_Get_Call {
	return &IArtistService_Get_Call{Call: _e.mock.On("Get", id)}
}

func (_c *IArtistService_Get_Call) Run(run func(id uint)) *IArtistService_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint))
	})
	return _c
}

func (_c *IArtistService_Get_Call) Return(artist *models.Artist, err error) *IArtistService_Get_Call {
	_c.Call.Return(artist, err)
	return _c
}

func (_c *IArtistService_Get_Call) RunAndReturn(run func(id uint) (*models.Artist, error)) *IArtistService_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetRandom provides a mock function for the type IArtistService
func (_mock *IArtistService) GetRandom() (*models.Artist, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetRandom")
	}

	var r0 *models.Artist
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (*models.Artist, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() *models.Artist); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Artist)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IArtistService_GetRandom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRandom'
type IArtistService_GetRandom_Call struct {
	*mock.Call
}

// GetRandom is a helper method to define mock.On call
func (_e *IArtistService_Expecter) GetRandom() *IArtistService_GetRandom_Call {
	return &IArtistService_GetRandom_Call{Call: _e.mock.On("GetRandom")}
}

func (_c *IArtistService_GetRandom_Call) Run(run func()) *IArtistService_GetRandom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IArtistService_GetRandom_Call) Return(artist *models.Artist, err error) *IArtistService_GetRandom_Call {
	_c.Call.Return(artist, err)
	return _c
}

func (_c *IArtistService_GetRandom_Call) RunAndReturn(run func() (*models.Artist, error)) *IArtistService_GetRandom_Call {
	_c.Call.Return(run)
	return _c
}

// NewIAuthService creates a new instance of IAuthService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIAuthService(t interface {
	mock.TestingT
	Cleanup(func())
}) *IAuthService {
	mock := &IAuthService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IAuthService is an autogenerated mock type for the IAuthService type
type IAuthService struct {
	mock.Mock
}

type IAuthService_Expecter struct {
	mock *mock.Mock
}

func (_m *IAuthService) EXPECT() *IAuthService_Expecter {
	return &IAuthService_Expecter{mock: &_m.Mock}
}

// GenerateJWT provides a mock function for the type IAuthService
func (_mock *IAuthService) GenerateJWT(name string, password string) (string, error) {
	ret := _mock.Called(name, password)

	if len(ret) == 0 {
		panic("no return value specified for GenerateJWT")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string) (string, error)); ok {
		return returnFunc(name, password)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = returnFunc(name, password)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = returnFunc(name, password)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IAuthService_GenerateJWT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateJWT'
type IAuthService_GenerateJWT_Call struct {
	*mock.Call
}

// GenerateJWT is a helper method to define mock.On call
//   - name
//   - password
func (_e *IAuthService_Expecter) GenerateJWT(name interface{}, password interface{}) *IAuthService_GenerateJWT_Call {
	return &IAuthService_GenerateJWT_Call{Call: _e.mock.On("GenerateJWT", name, password)}
}

func (_c *IAuthService_GenerateJWT_Call) Run(run func(name string, password string)) *IAuthService_GenerateJWT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *IAuthService_GenerateJWT_Call) Return(s string, err error) *IAuthService_GenerateJWT_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *IAuthService_GenerateJWT_Call) RunAndReturn(run func(name string, password string) (string, error)) *IAuthService_GenerateJWT_Call {
	_c.Call.Return(run)
	return _c
}

// IsAuthorized provides a mock function for the type IAuthService
func (_mock *IAuthService) IsAuthorized(token string) bool {
	ret := _mock.Called(token)

	if len(ret) == 0 {
		panic("no return value specified for IsAuthorized")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(token)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// IAuthService_IsAuthorized_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsAuthorized'
type IAuthService_IsAuthorized_Call struct {
	*mock.Call
}

// IsAuthorized is a helper method to define mock.On call
//   - token
func (_e *IAuthService_Expecter) IsAuthorized(token interface{}) *IAuthService_IsAuthorized_Call {
	return &IAuthService_IsAuthorized_Call{Call: _e.mock.On("IsAuthorized", token)}
}

func (_c *IAuthService_IsAuthorized_Call) Run(run func(token string)) *IAuthService_IsAuthorized_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IAuthService_IsAuthorized_Call) Return(b bool) *IAuthService_IsAuthorized_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *IAuthService_IsAuthorized_Call) RunAndReturn(run func(token string) bool) *IAuthService_IsAuthorized_Call {
	_c.Call.Return(run)
	return _c
}

// NewIDbHandler creates a new instance of IDbHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIDbHandler(t interface {
	mock.TestingT
	Cleanup(func())
}) *IDbHandler {
	mock := &IDbHandler{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IDbHandler is an autogenerated mock type for the IDbHandler type
type IDbHandler struct {
	mock.Mock
}

type IDbHandler_Expecter struct {
	mock *mock.Mock
}

func (_m *IDbHandler) EXPECT() *IDbHandler_Expecter {
	return &IDbHandler_Expecter{mock: &_m.Mock}
}

// Connection provides a mock function for the type IDbHandler
func (_mock *IDbHandler) Connection() *gorm.DB {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Connection")
	}

	var r0 *gorm.DB
	if returnFunc, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}
	return r0
}

// IDbHandler_Connection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connection'
type IDbHandler_Connection_Call struct {
	*mock.Call
}

// Connection is a helper method to define mock.On call
func (_e *IDbHandler_Expecter) Connection() *IDbHandler_Connection_Call {
	return &IDbHandler_Connection_Call{Call: _e.mock.On("Connection")}
}

func (_c *IDbHandler_Connection_Call) Run(run func()) *IDbHandler_Connection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IDbHandler_Connection_Call) Return(dB *gorm.DB) *IDbHandler_Connection_Call {
	_c.Call.Return(dB)
	return _c
}

func (_c *IDbHandler_Connection_Call) RunAndReturn(run func() *gorm.DB) *IDbHandler_Connection_Call {
	_c.Call.Return(run)
	return _c
}

// NewIFileUtil creates a new instance of IFileUtil. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIFileUtil(t interface {
	mock.TestingT
	Cleanup(func())
}) *IFileUtil {
	mock := &IFileUtil{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IFileUtil is an autogenerated mock type for the IFileUtil type
type IFileUtil struct {
	mock.Mock
}

type IFileUtil_Expecter struct {
	mock *mock.Mock
}

func (_m *IFileUtil) EXPECT() *IFileUtil_Expecter {
	return &IFileUtil_Expecter{mock: &_m.Mock}
}

// DeleteIfExists provides a mock function for the type IFileUtil
func (_mock *IFileUtil) DeleteIfExists(file string) error {
	ret := _mock.Called(file)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIfExists")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(file)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IFileUtil_DeleteIfExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIfExists'
type IFileUtil_DeleteIfExists_Call struct {
	*mock.Call
}

// DeleteIfExists is a helper method to define mock.On call
//   - file
func (_e *IFileUtil_Expecter) DeleteIfExists(file interface{}) *IFileUtil_DeleteIfExists_Call {
	return &IFileUtil_DeleteIfExists_Call{Call: _e.mock.On("DeleteIfExists", file)}
}

func (_c *IFileUtil_DeleteIfExists_Call) Run(run func(file string)) *IFileUtil_DeleteIfExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IFileUtil_DeleteIfExists_Call) Return(err error) *IFileUtil_DeleteIfExists_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IFileUtil_DeleteIfExists_Call) RunAndReturn(run func(file string) error) *IFileUtil_DeleteIfExists_Call {
	_c.Call.Return(run)
	return _c
}

// NewIStorageClient creates a new instance of IStorageClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIStorageClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IStorageClient {
	mock := &IStorageClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IStorageClient is an autogenerated mock type for the IStorageClient type
type IStorageClient struct {
	mock.Mock
}

type IStorageClient_Expecter struct {
	mock *mock.Mock
}

func (_m *IStorageClient) EXPECT() *IStorageClient_Expecter {
	return &IStorageClient_Expecter{mock: &_m.Mock}
}

// DeleteFile provides a mock function for the type IStorageClient
func (_mock *IStorageClient) DeleteFile(object string) error {
	ret := _mock.Called(object)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFile")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(object)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IStorageClient_DeleteFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFile'
type IStorageClient_DeleteFile_Call struct {
	*mock.Call
}

// DeleteFile is a helper method to define mock.On call
//   - object
func (_e *IStorageClient_Expecter) DeleteFile(object interface{}) *IStorageClient_DeleteFile_Call {
	return &IStorageClient_DeleteFile_Call{Call: _e.mock.On("DeleteFile", object)}
}

func (_c *IStorageClient_DeleteFile_Call) Run(run func(object string)) *IStorageClient_DeleteFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IStorageClient_DeleteFile_Call) Return(err error) *IStorageClient_DeleteFile_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IStorageClient_DeleteFile_Call) RunAndReturn(run func(object string) error) *IStorageClient_DeleteFile_Call {
	_c.Call.Return(run)
	return _c
}

// ListFiles provides a mock function for the type IStorageClient
func (_mock *IStorageClient) ListFiles() ([]storageclient.BackupFile, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ListFiles")
	}

	var r0 []storageclient.BackupFile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]storageclient.BackupFile, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []storageclient.BackupFile); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]storageclient.BackupFile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IStorageClient_ListFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListFiles'
type IStorageClient_ListFiles_Call struct {
	*mock.Call
}

// ListFiles is a helper method to define mock.On call
func (_e *IStorageClient_Expecter) ListFiles() *IStorageClient_ListFiles_Call {
	return &IStorageClient_ListFiles_Call{Call: _e.mock.On("ListFiles")}
}

func (_c *IStorageClient_ListFiles_Call) Run(run func()) *IStorageClient_ListFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IStorageClient_ListFiles_Call) Return(backupFiles []storageclient.BackupFile, err error) *IStorageClient_ListFiles_Call {
	_c.Call.Return(backupFiles, err)
	return _c
}

func (_c *IStorageClient_ListFiles_Call) RunAndReturn(run func() ([]storageclient.BackupFile, error)) *IStorageClient_ListFiles_Call {
	_c.Call.Return(run)
	return _c
}

// UploadFile provides a mock function for the type IStorageClient
func (_mock *IStorageClient) UploadFile(path string, destObject string) error {
	ret := _mock.Called(path, destObject)

	if len(ret) == 0 {
		panic("no return value specified for UploadFile")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = returnFunc(path, destObject)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IStorageClient_UploadFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadFile'
type IStorageClient_UploadFile_Call struct {
	*mock.Call
}

// UploadFile is a helper method to define mock.On call
//   - path
//   - destObject
func (_e *IStorageClient_Expecter) UploadFile(path interface{}, destObject interface{}) *IStorageClient_UploadFile_Call {
	return &IStorageClient_UploadFile_Call{Call: _e.mock.On("UploadFile", path, destObject)}
}

func (_c *IStorageClient_UploadFile_Call) Run(run func(path string, destObject string)) *IStorageClient_UploadFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *IStorageClient_UploadFile_Call) Return(err error) *IStorageClient_UploadFile_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IStorageClient_UploadFile_Call) RunAndReturn(run func(path string, destObject string) error) *IStorageClient_UploadFile_Call {
	_c.Call.Return(run)
	return _c
}

// NewIUserRepository creates a new instance of IUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *IUserRepository {
	mock := &IUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IUserRepository is an autogenerated mock type for the IUserRepository type
type IUserRepository struct {
	mock.Mock
}

type IUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *IUserRepository) EXPECT() *IUserRepository_Expecter {
	return &IUserRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type IUserRepository
func (_mock *IUserRepository) Create(name string, password string) (*models.User, error) {
	ret := _mock.Called(name, password)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string) (*models.User, error)); ok {
		return returnFunc(name, password)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) *models.User); ok {
		r0 = returnFunc(name, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = returnFunc(name, password)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IUserRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type IUserRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - name
//   - password
func (_e *IUserRepository_Expecter) Create(name interface{}, password interface{}) *IUserRepository_Create_Call {
	return &IUserRepository_Create_Call{Call: _e.mock.On("Create", name, password)}
}

func (_c *IUserRepository_Create_Call) Run(run func(name string, password string)) *IUserRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *IUserRepository_Create_Call) Return(user *models.User, err error) *IUserRepository_Create_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *IUserRepository_Create_Call) RunAndReturn(run func(name string, password string) (*models.User, error)) *IUserRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type IUserRepository
func (_mock *IUserRepository) Get(name string) (*models.User, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (*models.User, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *models.User); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IUserRepository_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type IUserRepository_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - name
func (_e *IUserRepository_Expecter) Get(name interface{}) *IUserRepository_Get_Call {
	return &IUserRepository_Get_Call{Call: _e.mock.On("Get", name)}
}

func (_c *IUserRepository_Get_Call) Run(run func(name string)) *IUserRepository_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *IUserRepository_Get_Call) Return(user *models.User, err error) *IUserRepository_Get_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *IUserRepository_Get_Call) RunAndReturn(run func(name string) (*models.User, error)) *IUserRepository_Get_Call {
	_c.Call.Return(run)
	return _c
}
